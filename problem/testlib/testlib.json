[{"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "acmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <stdio.h>\n#include <math.h>\n\nconst double EPS = 1.5E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two doubles, maximal absolute error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n    \n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n\n    if (fabs(ja - pa) > EPS + 1E-15)\n        quitf(_wa, \"expected %.10f, found %.10f\", ja, pa);\n    \n    quitf(_ok, \"answer is %.10f\", ja);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "caseicmp", "lang": "cpp", "code": "/**\n * Checker to compare output and answer in the form:\n *\n * Case 1: <number>\n * Case 2: <number>\n * ...\n * Case n: <number>\n *\n */\n\n#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nvector<long long> readStream(InStream& in, TResult pe)\n{\n    vector<long long> result;\n\n    for (int testCase = 1; !in.seekEof(); testCase++)\n    {\n        string caseStr = in.readToken();\n        if (caseStr != \"Case\")\n            quitf(pe, \"Expected 'Case' but found '%s' [test case %d]\", compress(caseStr).c_str(), testCase);\n\n        string numExpStr;\n        stringstream ss;\n        ss << testCase;\n        ss >> numExpStr;\n        numExpStr += \":\";\n        string numStr = in.readToken();\n        if (numExpStr != numStr)\n            quitf(pe, \"Expected '%s' but found '%s' [test case %d]\", compress(numExpStr).c_str(), compress(numStr).c_str(), testCase);\n\n        result.push_back(in.readLong());\n    }\n\n    return result;\n}\n\nint main(int argc, char* argv[])\n{\n    setName(\"Single int64 checker with testcase-support\");\n    registerTestlibCmd(argc, argv);\n\n    vector<long long> ja = readStream(ans, _fail);\n    vector<long long> pa = readStream(ouf, _pe);\n\n    forn(i, min(ja.size(), pa.size()))\n        if (ja[i] != pa[i])\n            quitf(_wa, \"Expected %s found %s [test case %d]\", vtos(ja[i]).c_str(), vtos(pa[i]).c_str(), i + 1);\n\n    if (ja.size() != pa.size())\n        quitf(_pe, \"Expected %u test case(s) but found %u\", (unsigned int)(ja.size()), (unsigned int)(pa.size()));\n\n    string message = format(\"%u case(s):\", (unsigned int)(ja.size()));\n    if (ja.size() <= 5)\n    {\n        forn(i, ja.size())\n            message += \" \" + vtos(ja[i]);\n    }\n    else\n    {\n        forn(i, 3)\n            message += \" \" + vtos(ja[i]);\n        message += \" ...\";\n        forn(i, 2)\n            message += \" \" + vtos(ja[ja.size() - 2 + i]);\n    }\n\n    quitf(_ok, \"%s\", message.c_str());\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "casencmp", "lang": "cpp", "code": "/**\n * Checker to compare output and answer in the form:\n *\n * Case 1: <number> <number> <number> ... <number>\n * Case 2: <number> <number> <number> ... <number>\n * ...\n * Case n: <number> <number> <number> ... <number>\n *\n */\n\n#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nstring token;\n\nvector<long long> readStreamCase(InStream& in, TResult pe, int testCase, bool& prereadCase)\n{\n    if (!prereadCase)\n    {\n        string caseStr = in.readToken();\n        if (caseStr != \"Case\")\n            quitf(pe, \"Expected 'Case' but found '%s' [test case %d]\", compress(caseStr).c_str(), testCase);\n    }\n\n    string numExpStr;\n    stringstream ss;\n    ss << testCase;\n    ss >> numExpStr;\n    numExpStr += \":\";\n    string numStr = in.readToken();\n    if (numExpStr != numStr)\n        quitf(pe, \"Expected '%s' but found '%s' [test case %d]\", compress(numExpStr).c_str(), compress(numStr).c_str(), testCase);\n\n    vector<long long> result;\n    while (!in.seekEof())\n    {\n        in.readTokenTo(token);\n        if (token == \"Case\")\n        {\n            prereadCase = true;\n            break;\n        }\n\n        result.push_back(stringToLongLong(in, token.c_str()));\n    }\n\n    return result;\n}\n\nstring longLongsToString(const vector<long long>& a)\n{\n    if (a.empty())\n        return \"\\\"\\\" [size=0]\";\n    \n    string elems;\n    if (a.size() <= 5)\n    {\n        forn(i, a.size())\n            elems += vtos(a[i]) + \" \";\n    }\n    else\n    {\n        forn(i, 3)\n            elems += vtos(a[i]) + \" \";\n        elems += \"... \";\n        forn(i, 2)\n            elems += vtos(a[a.size() - 2 + i]) + \" \";\n    }\n\n    return format(\"\\\"%s\\\" [size=%u]\", trim(elems).c_str(), (unsigned int)(a.size()));\n}\n\nint main(int argc, char* argv[])\n{\n    setName(\"Many int64s checker with testcase-support\");\n    registerTestlibCmd(argc, argv);\n\n    int testCase = 0;\n\n    bool ansPrereadCase = false;\n    bool oufPrereadCase = false;\n\n    while (!ans.seekEof())\n    {\n        testCase++;\n\n        vector<long long> ja = readStreamCase(ans, _fail, testCase, ansPrereadCase);\n        vector<long long> pa = readStreamCase(ouf, _pe, testCase, oufPrereadCase);\n\n        if (ja != pa)\n        {\n            string js = longLongsToString(ja);\n            string ps = longLongsToString(pa);\n            quitf(_wa, \"Sequences differ: jury has %s, but participant has %s [test case %d]\", js.c_str(), ps.c_str(), testCase);\n        }\n    }\n\n    quitf(_ok, \"%d test cases(s)\", testCase);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "casewcmp", "lang": "cpp", "code": "/**\n * Checker to compare output and answer in the form:\n *\n * Case 1: <token> <token> ... <token>\n * Case 2: <token> <token> ... <token>\n * ...\n * Case n: <token> <token> ... <token>\n *\n */\n\n#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nstring token;\n\nvector<string> readStreamCase(InStream& in, TResult pe, int testCase, bool& prereadCase)\n{\n    if (!prereadCase)\n    {\n        string caseStr = in.readToken();\n        if (caseStr != \"Case\")\n            quitf(pe, \"Expected 'Case' but found '%s' [test case %d]\", compress(caseStr).c_str(), testCase);\n    }\n\n    string numExpStr;\n    stringstream ss;\n    ss << testCase;\n    ss >> numExpStr;\n    numExpStr += \":\";\n    string numStr = in.readToken();\n    if (numExpStr != numStr)\n        quitf(pe, \"Expected '%s' but found '%s' [test case %d]\", compress(numExpStr).c_str(), compress(numStr).c_str(), testCase);\n\n    vector<string> result;\n    while (!in.seekEof())\n    {\n        in.readTokenTo(token);\n        if (token == \"Case\")\n        {\n            prereadCase = true;\n            break;\n        }\n\n        result.push_back(token);\n    }\n\n    return result;\n}\n\nstring stringsToString(const vector<string>& a)\n{\n    if (a.empty())\n        return \"\\\"\\\" [size=0]\";\n    \n    string elems;\n    forn(i, a.size())\n        elems += a[i] + \" \";\n\n    return format(\"\\\"%s\\\" [size=%u]\", compress(trim(elems)).c_str(), (unsigned int)(a.size()));\n}\n\nint main(int argc, char* argv[])\n{\n    setName(\"Tokens checker with testcase-support\");\n    registerTestlibCmd(argc, argv);\n\n    int testCase = 0;\n\n    bool ansPrereadCase = false;\n    bool oufPrereadCase = false;\n\n    while (!ans.seekEof())\n    {\n        testCase++;\n\n        vector<string> ja = readStreamCase(ans, _fail, testCase, ansPrereadCase);\n        vector<string> pa = readStreamCase(ouf, _pe, testCase, oufPrereadCase);\n\n        if (ja != pa)\n        {\n            string js = stringsToString(ja);\n            string ps = stringsToString(pa);\n            quitf(_wa, \"Sequences differ: jury has %s, but participant has %s [test case %d]\", js.c_str(), ps.c_str(), testCase);\n        }\n    }\n\n    quitf(_ok, \"%d test cases(s)\", testCase);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "dcmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <stdio.h>\n#include <math.h>\n\nconst double EPS = 1E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two doubles, maximal absolute or relative error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n    \n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n    \n    if (!doubleCompare(ja, pa, EPS))\n        quitf(_wa, \"expected %.10f, found %.10f\", ja, pa);\n    \n    quitf(_ok, \"answer is %.10f\", ja);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "fcmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare files as sequence of lines\");\n    registerTestlibCmd(argc, argv);\n\n    std::string strAnswer;\n\n    int n = 0;\n    while (!ans.eof()) \n    {\n        std::string j = ans.readString();\n\n        if (j == \"\" && ans.eof())\n          break;\n\n        strAnswer = j;\n        std::string p = ouf.readString();\n\n        n++;\n\n        if (j != p)\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), compress(j).c_str(), compress(p).c_str());\n    }\n    \n    if (n == 1)\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\n    \n    quitf(_ok, \"%d lines\", n);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "hcmp", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <string>\n\nusing namespace std;\n\npattern pnum(\"0|-?[1-9][0-9]*\");\n\nbool isNumeric(const string& p)\n{\n    return pnum.matches(p);\n}\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two signed huge integers\");\n    registerTestlibCmd(argc, argv);\n    \n    string ja = ans.readWord();\n    string pa = ouf.readWord();\n\n    if (!isNumeric(ja))\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\n\n    if (!ans.seekEof())\n        quitf(_fail, \"expected exactly one token in the answer file\");\n    \n    if (!isNumeric(pa))\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\n\n    if (ja != pa)\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\n    \n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "icmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <stdio.h>\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two signed int%ld's\", 8 * sizeof(int));\n    registerTestlibCmd(argc, argv);\n    \n    int ja = ans.readInt();\n    int pa = ouf.readInt();\n    \n    if (ja != pa)\n        quitf(_wa, \"expected %d, found %d\", ja, pa);\n    \n    quitf(_ok, \"answer is %d\", ja);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "lcmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nbool compareWords(string a, string b)\n{\n    vector<string> va, vb;\n    stringstream sa;\n    \n    sa << a;\n    string cur;\n    while (sa >> cur)\n        va.push_back(cur);\n\n    stringstream sb;\n    sb << b;\n    while (sb >> cur)\n        vb.push_back(cur);\n\n    return (va == vb);\n}\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare files as sequence of tokens in lines\");\n    registerTestlibCmd(argc, argv);\n\n    std::string strAnswer;\n\n    int n = 0;\n    while (!ans.eof()) \n    {\n        std::string j = ans.readString();\n\n        if (j == \"\" && ans.eof())\n          break;\n        \n        std::string p = ouf.readString();\n        strAnswer = p;\n\n        n++;\n\n        if (!compareWords(j, p))\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), compress(j).c_str(), compress(p).c_str());\n    }\n    \n    if (n == 1)\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\n    \n    quitf(_ok, \"%d lines\", n);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "ncmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <sstream>\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare ordered sequences of signed int%ld numbers\", 8 * sizeof(long long));\n\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    string firstElems;\n\n    while (!ans.seekEof() && !ouf.seekEof())\n    {\n        n++;\n        long long j = ans.readLong();\n        long long p = ouf.readLong();\n        if (j != p)\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), vtos(j).c_str(), vtos(p).c_str());\n        else\n            if (n <= 5)\n            {\n                if (firstElems.length() > 0)\n                    firstElems += \" \";\n                firstElems += vtos(j);\n            }\n    }\n\n    int extraInAnsCount = 0;\n\n    while (!ans.seekEof())\n    {\n        ans.readLong();\n        extraInAnsCount++;\n    }\n    \n    int extraInOufCount = 0;\n\n    while (!ouf.seekEof())\n    {\n        ouf.readLong();\n        extraInOufCount++;\n    }\n\n    if (extraInAnsCount > 0)\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\", n + extraInAnsCount, n);\n    \n    if (extraInOufCount > 0)\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\", n + extraInOufCount, n);\n    \n    if (n <= 5)\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\n    else\n        quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "pointscmp", "lang": "cpp", "code": "#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"example of scored checker\");\n    registerTestlibCmd(argc, argv);\n\n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n\n    quitp(fabs(ja - pa), \"ja=%.4f pa=%.4f\", ja, pa);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "rcmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <stdio.h>\n#include <math.h>\n\nconst double EPS = 1.5E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two doubles, maximal absolute error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n    \n    double ja = ans.readDouble();\n    double pa = ouf.readDouble();\n\n    if (fabs(ja - pa) > EPS + 1E-15)\n        quitf(_wa, \"expected %.10f, found %.10f\", ja, pa);\n    \n    quitf(_ok, \"answer is %.10f\", ja);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "rcmp4", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1E-4;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    double j = 0, p = 0;\n\n    while (!ans.seekEof()) \n    {\n        n++;\n        j = ans.readDouble();\n        p = ouf.readDouble();\n        if (!doubleCompare(j, p, EPS))\n        {\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\n                n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\n        }\n    }\n\n    if (n == 1)\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\n    \n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "rcmp6", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    double j = 0, p = 0;\n\n    while (!ans.seekEof()) \n    {\n        n++;\n        j = ans.readDouble();\n        p = ouf.readDouble();\n        if (!doubleCompare(j, p, EPS))\n        {\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\n                n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\n        }\n    }\n\n    if (n == 1)\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\n\n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "rcmp9", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1E-9;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    double j = 0, p = 0;\n\n    while (!ans.seekEof()) \n    {\n        n++;\n        j = ans.readDouble();\n        p = ouf.readDouble();\n        if (!doubleCompare(j, p, EPS))\n        {\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\n                n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\n        }\n    }\n\n    if (n == 1)\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\n\n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "rncmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.5E-5;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare two sequences of doubles, maximal absolute error = %.10f\", EPS);\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    while (!ans.seekEof()) \n    {\n        n++;\n        double j = ans.readDouble();\n        double p = ouf.readDouble();\n        if (fabs(j - p) > EPS + 1E-15)\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f'\", n, englishEnding(n).c_str(), j, p);\n    }\n\n    quitf(_ok, \"%d numbers\", n);\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "uncmp", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare unordered sequences of signed int%lu numbers\", 8 * sizeof(long long));\n\n    registerTestlibCmd(argc, argv);\n\n    vector<long long> ja, pa;\n\n    while (!ans.seekEof())\n        ja.push_back(ans.readLong());\n\n    while (!ouf.seekEof())\n        pa.push_back(ouf.readLong());\n\n    if (ja.size() != pa.size())\n        quitf(_wa, \"Expected %u elements, but %u found\", (unsigned int)(ja.size()), (unsigned int)(pa.size()));\n\n    sort(ja.begin(), ja.end());\n    sort(pa.begin(), pa.end());\n\n    if (ja != pa)\n        quitf(_wa, \"Expected sequence and output are different (as unordered sequences) [size=%u]\", (unsigned int)(ja.size()));\n\n    string message;\n    \n    if (ja.size() != 1)\n        if (ja.empty())\n            message = \"empty sequence\";\n        else\n            message = vtos(ja.size()) + \" numbers (in increasing order):\";\n    else\n        message = vtos(ja.size()) + \" number:\";\n    \n    if (ja.size() <= 5)\n        for (int i = 0; i < min(int(ja.size()), 5); i++)\n            message += \" \" + vtos(ja[i]);\n    else\n    {\n        for (int i = 0; i < 2; i++)\n            message += \" \" + vtos(ja[i]);\n        message += \" ...\";\n        for (int i = 0; i < 2; i++)\n            message += \" \" + vtos(ja[ja.size() - 2 + i]);\n    }\n        \n    quitf(_ok, \"%s\", message.c_str());\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "wcmp", "lang": "cpp", "code": "#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    setName(\"compare sequences of tokens\");\n    registerTestlibCmd(argc, argv);\n\n    int n = 0;\n    string j, p;\n\n    while (!ans.seekEof() && !ouf.seekEof()) \n    {\n        n++;\n\n        ans.readWordTo(j);\n        ouf.readWordTo(p);\n        \n        if (j != p)\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(), compress(j).c_str(), compress(p).c_str());\n    }\n\n    if (ans.seekEof() && ouf.seekEof())\n    {\n        if (n == 1)\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\n        else\n            quitf(_ok, \"%d tokens\", n);\n    }\n    else\n    {\n        if (ans.seekEof())\n            quitf(_wa, \"Participant output contains extra tokens\");\n        else\n            quitf(_wa, \"Unexpected EOF in the participants output\");\n    }\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "checker", "name": "yesno", "lang": "cpp", "code": "#include \"testlib.h\"\n#include <string>\n\nusing namespace std;\n\nconst string YES = \"YES\";\nconst string NO = \"NO\";\n\nint main(int argc, char * argv[])\n{\n    setName(\"%s\", (YES + \" or \" + NO + \" (case insensetive)\").c_str());\n    registerTestlibCmd(argc, argv);\n\n    std::string ja = upperCase(ans.readWord());\n    std::string pa = upperCase(ouf.readWord());\n\n    if (ja != YES && ja != NO)\n        quitf(_fail, \"%s or %s expected in answer, but %s found\", YES.c_str(), NO.c_str(), compress(ja).c_str());\n\n    if (pa != YES && pa != NO)\n        quitf(_pe, \"%s or %s expected, but %s found\", YES.c_str(), NO.c_str(), compress(pa).c_str());\n\n    if (ja != pa)\n        quitf(_wa, \"expected %s, found %s\", compress(ja).c_str(), compress(pa).c_str());\n\n    quitf(_ok, \"answer is %s\", ja.c_str());\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "bgen", "lang": "cpp", "code": "/*\n * Outputs random 100-digits binary string mostly containing 0's. \n * In average it contrains only 10% of 1's.\n *\n * To generate different values, call \"bgen.exe\" with different parameters.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.next(\"[0000000001]{100}\") << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "gen-bipartite-graph", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = atoi(argv[1]);\n    int m = atoi(argv[2]);\n    size_t k = atoi(argv[3]);\n\n    int t = rnd.next(-2, 2);\n\n    set<pair<int,int> > edges;\n\n    while (edges.size() < k)\n    {\n        int a = rnd.wnext(n, t);\n        int b = rnd.wnext(m, t);\n        edges.insert(make_pair(a, b));\n    }\n\n    vector<pair<int,int> > e(edges.begin(), edges.end());\n    shuffle(e.begin(), e.end());\n\n    vector<int> pa(n);\n    for (int i = 0; i < n; i++)\n        pa[i] = i + 1;\n    shuffle(pa.begin(), pa.end());\n\n    vector<int> pb(m);\n    for (int i = 0; i < m; i++)\n        pb[i] = i + 1;\n    shuffle(pb.begin(), pb.end());\n\n    cout << n << \" \" << m << \" \" << e.size() << endl;\n\n    forn(i, e.size())\n        cout << pa[e[i].first] << \" \" << pb[e[i].second] << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "gen-rooted-tree-graph", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = atoi(argv[1]);\n    int t = atoi(argv[2]);\n\n    vector<int> p(n);\n    forn(i, n)\n        if (i > 0)\n            p[i] = rnd.wnext(i, t);\n\n    printf(\"%d\\n\", n);\n    vector<int> perm(n);\n    forn(i, n)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    vector<int> pp(n);\n    for (int i = 1; i < n; i++)\n        pp[perm[i]] = perm[p[i]];\n\n    for (int i = 1; i < n; i++)\n    {\n        printf(\"%d\", pp[i] + 1);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "gen-tree-graph", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = atoi(argv[1]);\n    int t = atoi(argv[2]);\n\n    vector<int> p(n);\n    forn(i, n)\n        if (i > 0)\n            p[i] = rnd.wnext(i, t);\n\n    printf(\"%d\\n\", n);\n    vector<int> perm(n);\n    forn(i, n)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n    vector<pair<int,int> > edges;\n\n    for (int i = 1; i < n; i++)\n        if (rnd.next(2))\n            edges.push_back(make_pair(perm[i], perm[p[i]]));\n        else\n            edges.push_back(make_pair(perm[p[i]], perm[i]));\n\n    shuffle(edges.begin(), edges.end());\n\n    for (int i = 0; i + 1 < n; i++)\n        printf(\"%d %d\\n\", edges[i].first + 1, edges[i].second + 1);\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "igen", "lang": "cpp", "code": "/*\n * Outputs random number between 1 and 10^6, inclusive.\n * To generate different values, call \"igen.exe\" with different parameters.\n * For example, \"igen.exe 1\" returns 504077, but \"igen.exe 3\" returns 808747.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.next(1, 1000000) << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "iwgen", "lang": "cpp", "code": "/*\n * Outputs weighted random number between 1 and 10^6, inclusive.\n * To generate different values, call \"nwgen.exe weight\". \n *\n * If parameter \"weight\" \n * is equals to 0 than used uniformly distributed random.\n *\n * If parameter \"weight\" > 0 then you can think about it as code like this:\n * <code>\n * result = rnd.next(1, 1000000);\n * for (int i = 0; i < weight; i++)\n *     result = max(result, rnd.next(1, 1000000));\n * </code> \n * \n * If parameter \"weight\" < 0 then you can think about it as code like this:\n * <code>\n * result = rnd.next(1, 1000000);\n * for (int i = 0; i < -weight; i++)\n *     result = min(result, rnd.next(1, 1000000));\n * </code> \n *\n * It is typical behaviour of \"wnext\" methods to use this strategy to \n * generate off-center random distribution.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.wnext(1, 1000000, atoi(argv[1])) << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "multigen", "lang": "cpp", "code": "/*\n * It is another type of generators. It writes several files named \n * as test indices. \n *\n * For example, this generator writes 10 files (tests) from 1 to 10.\n * This type of generators supported by Polygon too, but I believe \n * that stdout-generators are more preferred.\n *\n * The generator for A+B problem, generates 10 tests where each \n * number is between 1 and 100, and tests grow with indices.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nvoid writeTest(int test)\n{\n    startTest(test);\n    \n    cout << rnd.next(1, test * test) \n        << \" \" << rnd.next(1, test * test) << endl;\n}\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    for (int i = 1; i <= 10; i++)\n        writeTest(i);\n    \n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "sgen", "lang": "cpp", "code": "/*\n * Outputs random token.\n *\n * Token contains latin letters and digits and have length \n * between 1 and 1000 characters, inclusive.\n *\n * To generate different values, call \"sgen.exe\" with different parameters.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    cout << rnd.next(\"[a-zA-Z0-9]{1,1000}\") << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "generator", "name": "swgen", "lang": "cpp", "code": "/*\n * Outputs random token.\n *\n * Token contains latin letters and digits and have length \n * between 1 and 1000 characters, inclusive.\n *\n * To generate different values, call \"swgen.exe <weight>\".\n * See \"iwgen.cpp\" and \"wnext()\" documentation for details.\n * For example, \"swgen.exe -1000\" generates short strings and \"swgen.exe 1000\"\n * generates long strings.\n * \n * It is typical behaviour of testlib generator to setup randseed by command line.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int length = rnd.wnext(1, 1000, atoi(argv[1]));\n    cout << rnd.next(\"[a-zA-Z0-9]{1,%d}\", length) << endl;\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "bipartite-graph-validator", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * m, \"k\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, k)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b_i\");\n        inf.readEoln();\n\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n        edges.insert(make_pair(a, b));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "ival", "lang": "cpp", "code": "/**\n * Validates that input contains the only integer between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "nval", "lang": "cpp", "code": "/**\n * Validates that the first line contains the integer between 1 and 10^5, inclusive.\n * The second line should contains space-separated sequence of integers between -10^15 and 10^15, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++)\n    {\n        inf.readLong(-1000000000000000LL, 1000000000000000LL, format(\"a[%d]\", i + 1));\n\n        if (i + 1 < n)\n            inf.readSpace();\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "sval", "lang": "cpp", "code": "/**\n * Validates that the input contains the only token token.\n * This token can contain only lowercase latin letters a-z. The length should be between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    inf.readToken(\"[a-z]{1,100}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "undirected-graph-validator", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, m)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Graph can't contain loops\");\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(a, b));\n        edges.insert(make_pair(b, a));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "undirected-tree-validator", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint leader(vector<int>& dsu, int idx)\n{\n    return dsu[idx] == idx ? dsu[idx] : (dsu[idx] = leader(dsu, dsu[idx]));\n}\n\nbool merge(vector<int>& dsu, int a, int b)\n{\n    a = leader(dsu, a);\n    b = leader(dsu, b);\n    if (a == b)\n        return false;\n    else\n    {\n        if (rnd.next(2) == 0)\n            dsu[a] = b;\n        else\n            dsu[b] = a;\n        return true;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> dsu(n);\n    forn(i, n)\n        dsu[i] = i;\n\n    set<pair<int,int> > edges;\n\n    forn(i, n - 1)\n    {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Tree can't contain loops\");\n        ensuref(edges.count(make_pair(x, y)) == 0, \"Tree can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(x, y));\n        edges.insert(make_pair(y, x));\n\n        ensuref(merge(dsu, x - 1, y - 1), \"Tree can't contain cycles\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "validate-using-testset-and-group", "lang": "cpp", "code": "/**\n * Validates that input depenging on testset and group.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n, m;\n\n    if (validator.testset() == \"pretests\")\n    {\n        n = inf.readInt(1, 10, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 10, \"m\");\n    }\n    else\n    {\n        n = inf.readInt(1, 100, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 100, \"m\");\n    }\n\n    if (validator.group() == \"even-n-and-m\")\n    {\n        ensure(n % 2 == 0);\n        ensure(m % 2 == 0);\n    }\n\n    inf.readEoln();\n    inf.readEof();\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "bipartite-graph-validator", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * m, \"k\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, k)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b_i\");\n        inf.readEoln();\n\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n        edges.insert(make_pair(a, b));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "ival", "lang": "cpp", "code": "/**\n * Validates that input contains the only integer between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "nval", "lang": "cpp", "code": "/**\n * Validates that the first line contains the integer between 1 and 10^5, inclusive.\n * The second line should contains space-separated sequence of integers between -10^15 and 10^15, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++)\n    {\n        inf.readLong(-1000000000000000LL, 1000000000000000LL, format(\"a[%d]\", i + 1));\n\n        if (i + 1 < n)\n            inf.readSpace();\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "sval", "lang": "cpp", "code": "/**\n * Validates that the input contains the only token token.\n * This token can contain only lowercase latin letters a-z. The length should be between 1 and 100, inclusive.\n * Also validates that file ends with EOLN and EOF.\n */\n\n#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n    \n    inf.readToken(\"[a-z]{1,100}\", \"s\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "undirected-graph-validator", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int> > edges;\n\n    forn(i, m)\n    {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Graph can't contain loops\");\n        ensuref(edges.count(make_pair(a, b)) == 0, \"Graph can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(a, b));\n        edges.insert(make_pair(b, a));\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "undirected-tree-validator", "lang": "cpp", "code": "#include \"testlib.h\"\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <algorithm>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nint leader(vector<int>& dsu, int idx)\n{\n    return dsu[idx] == idx ? dsu[idx] : (dsu[idx] = leader(dsu, dsu[idx]));\n}\n\nbool merge(vector<int>& dsu, int a, int b)\n{\n    a = leader(dsu, a);\n    b = leader(dsu, b);\n    if (a == b)\n        return false;\n    else\n    {\n        if (rnd.next(2) == 0)\n            dsu[a] = b;\n        else\n            dsu[b] = a;\n        return true;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> dsu(n);\n    forn(i, n)\n        dsu[i] = i;\n\n    set<pair<int,int> > edges;\n\n    forn(i, n - 1)\n    {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Tree can't contain loops\");\n        ensuref(edges.count(make_pair(x, y)) == 0, \"Tree can't contain multiple edges between a pair of vertices\");\n\n        edges.insert(make_pair(x, y));\n        edges.insert(make_pair(y, x));\n\n        ensuref(merge(dsu, x - 1, y - 1), \"Tree can't contain cycles\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n"}}, {"model": "problem.TrustedSubmission", "fields": {"category": "validator", "name": "validate-using-testset-and-group", "lang": "cpp", "code": "/**\n * Validates that input depenging on testset and group.\n */\n\n#include \"testlib.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n, m;\n\n    if (validator.testset() == \"pretests\")\n    {\n        n = inf.readInt(1, 10, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 10, \"m\");\n    }\n    else\n    {\n        n = inf.readInt(1, 100, \"n\");\n        inf.readSpace();\n        m = inf.readInt(1, 100, \"m\");\n    }\n\n    if (validator.group() == \"even-n-and-m\")\n    {\n        ensure(n % 2 == 0);\n        ensure(m % 2 == 0);\n    }\n\n    inf.readEoln();\n    inf.readEof();\n}\n"}}]